# Как выполняется блок

У самого блока нет публичного метода `run` — есть приватный `_run`.
Выполнение блока инициируется вызовом метода `run` у контекста:

```js
const promise = context.run( block, params );
```

Или же, если блок является под-блоком другого блока, метод `_run` блока
вызывается родительским блоком.

В любом случае, каким-то образом случается вызов

```js
block._run( params, context, state )
```

Дальше происходит довольно длинная цепочка разных действий.
Каждое из них опционально и выполняется только при наличии
соответствующих `options.*`. Если в `options` ничего нужного нет,
этот пункт пропускается.

Все функции, которые можно задать в `options.*` (`option.guard`,
`options.before`, ...), как правило имеют сигнатуру:

```js
function( params, context, state ) { ... }
```

Или иногда, когда уже доступен результат блока:

```js
function( params, context, state, result ) { ... }
```

**Важно**. `params` здесь бывают разные. До определенного момента
используются те `params`, которые были переданы в `block._run( params, ... )`.
Т.е. `deps`, `guard`, `before` и т.д. используют оригинальные параметры.
Непосредственно перед выполнением экшена блока (чтение файла, http-запрос, ...)
вычисляются новые параметры (если у блока есть `options.params` и/или `options.valid_params`)
и дальше уже используются именно они.

Более подробно о том, на что и как именно влияет та или иная [опция](./options.md).


## `options.isolate_state`

Текущий стейт копируется и дальше используется копия.


## `options.deps` и `options.pre_conditions`

Проверяем, можно ли запускать блок в данный момент. Ждем, если нельзя.


## `options.guard`

Вычисляем значение гарда (может быть несколько),
если значение ложно (хотя бы одно), завершаем выполнение блока с ошибкой `BLOCK_GUARDED`.
На самом деле, это не совсем ошибка — скорее warning.


## `options.before`

Выполняем последовательно все функции из `options.before` (может быть несколько).
Если любая из них возвращает ошибку, то выполнение блока завершается с этой ошибкой.

**FIXME:** Возможно, нужно как-то в `do_phase_after` сперва сходить. И иметь возможность отменить ошибку?
Или заменить.


## `options.key` и `options.maxage`

Пытаемся достать значение блока из кэша.
Вычисляем значение ключа и идем в `context.cache.get(key)` —
может вернуть само значение или же промис.
Если что-то достали (не `undefined`, не ошибку), то используем это значение
и переходим к `options.after`.


## `options.params` и `options.valid_params`.

Вычисляем параметры, которые будут использоваться для запуска блока.
Дальше везде `params` это то, что мы тут вычислили, и во все `options.*` функции
будут передаваться именно они.


## action

Дальше собственно выполняем основное действие блока: http-запрос, чтение файла и т.д.
Если получили ошибку, то все. См. `options.before`.

**Важно**. Начиная с этого момента во все `options.*` теперь четвертым аргументом
приходит то, что мы в этой фазе получили.


## `options.select`

Если есть `options.select`, вычисляем соответствующие значение и кладем их в стейт.


## `options.after`

Аналогично `options.before`.


## `options.result`

Вычисляем финальный результат выполнения блока. Если у нас несколько функций в `options.result`,
то первая получает четвертым параметром оригинальный результат, полученный в action,
а каждая последующая — результат предыдущей.


## `options.template`

**FIXME:** Чем это вообще отличается от result?
Накладываем на результат шаблон, на выходе по идее получаем html.
Кажется, можно это же делать и в result.


Все. Тем, что мы к этому моменту получили, резолвится промис, возвращаемый `block._run( ... )`.

